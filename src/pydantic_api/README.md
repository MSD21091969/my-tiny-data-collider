# Pydantic API

FastAPI surface for the YAML-driven tool framework. Routes are thin wrappers over the service layer and operate on the Pydantic envelopes described in the project `README.md` and `INSTALL.md`.

> **Getting ready?** Run the clean-slate workflow documented in the root docs first (clone → create venv → `pip install -e ".[dev]"` → `python scripts/generate_tools.py` → `python scripts/import_generated_tools.py`) so the autogenerated packages are present before you bring up the API.

## Layout

```

├── app.py             # FastAPI factory, CORS, health endpoint
├── dependencies.py    # Service singletons + auth helpers
└── routers/
    ├── casefile.py        # Casefile CRUD + ACL management
    ├── tool_session.py    # Tool sessions, execution, discovery
    └── chat.py            # Chat sessions + messaging (optional import)
```

- `app.py` builds the application, wires CORS, mounts routers, and exposes `/health`.
- `dependencies.py` caches service instances (`ToolSessionService`) and exposes helpers (`get_current_user_id`, `verify_casefile_access`).
- Routers coordinate request validation and security checks before delegating to the service layer.

## Router Highlights

### `tool_session.py`
- Creates sessions tied to a casefile; enforces ownership via `CasefileService`.
- Executes tools by validating the session, pulling the definition from `MANAGED_TOOLS`, and passing `ToolRequest` to `ToolSessionService`.
- Provides discovery endpoints:
  - `GET /tool-sessions/tools` → filtered list of registered tools.
  - `GET /tool-sessions/tools/{name}` → metadata/business rules.
  - `GET /tool-sessions/tools/{name}/schema` → OpenAPI schema for parameters.
- Accepts `CreateSessionRequest` envelopes from `src.pydantic_models.operations.tool_session_ops` when establishing new sessions.

### `casefile.py`
- Implements CRUD operations using `CreateCasefileRequest`, `UpdateCasefileRequest`, etc.
- Wraps ACL actions (grant, revoke, list, check self) with permission checks exposed by `CasefileACL`.
- Supports session linkage so tool/chat sessions can be associated with a casefile.

### `chat.py`
- Handles chat session lifecycle and messaging via `CommunicationService`.
- Accepts `RequestEnvelope` payloads so callers can attach auth metadata, while the router overwrites `user_id` with the JWT subject.
- Optional: only mounted if the chat service is available/importable.

## Request / Response Pattern

Routers accept/return the models in `src/pydantic_models/operations/**`. Even when query parameters are used for convenience (e.g. `create_casefile` query args), the router wraps/unwraps into the appropriate envelope before calling the service.

```python
from src.pydantic_models.operations.tool_execution_ops import ToolRequest
from src.pydantic_api.dependencies import get_tool_session_service

@router.post("/tool-sessions/execute")
async def execute_tool(request: ToolRequest, service = Depends(get_tool_session_service)):
    return await service.process_tool_request(request)
```

## Session Lifecycle Example

```python
from fastapi import Depends
from src.pydantic_api.dependencies import get_tool_session_service
from src.pydantic_models.operations.tool_session_ops import CreateSessionRequest


@router.post("/tool-sessions")
async def create_session(
    request: CreateSessionRequest,
    service = Depends(get_tool_session_service),
):
    """Provision a session bound to a casefile/user."""
    return await service.create_session(request)
```

Responses are always `BaseResponse[PayloadT]` objects returned by the service layer, matching the contract described in `INSTALL.md`.

## Dependencies & Auth

- Authentication uses `authservice.get_current_user`, which injects the JWT subject into each handler.
- `verify_casefile_access` currently returns `True` in development; production deployments should extend it to call `CasefileService.check_permission`.
- Services are lightweight wrappers around Firestore repositories (`tool_sessionservice`, `casefileservice`, `communicationservice`). Each router is responsible for verifying the requesting user matches the session/casefile owner before delegating.

For end-to-end usage, follow the workflow in `INSTALL.md`:
1. Bootstrap the repo (`pip install -e ".[dev]"`, `python scripts/generate_tools.py`, `python scripts/import_generated_tools.py`).
2. Start the API via:
    ```powershell
    uvicorn src.pydantic_api.app:app --reload
    ```
3. Exercise endpoints via the generated docs at `/docs` or the pytest suites under `tests/api/`.
