"""Auto-generated tool: echo_chain_demo

Generated from: config/tools/echo_chain_demo.yaml
DO NOT EDIT THIS FILE MANUALLY - Changes will be overwritten

This tool is part of the pydantic_ai_integration tool engineering foundation.
It was generated by the Tool Factory and automatically registered with MANAGED_TOOLS.
"""
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List
from ...tool_decorator import register_mds_tool
from ...dependencies import MDSContext
from ...execution.chain_executor import ChainExecutor


class EchochaindemoParams(BaseModel):
    """Parameters for echo_chain_demo.
    
    Demonstration of composite tool that chains multiple echo_tool calls
    """
    initial_message: str = Field(
...,
min_length=1,        description="Initial message to start the chain"
    )

    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "initial_message": 'Hello from composite tool'                }
            ]
        }


@register_mds_tool(
    name="echo_chain_demo",
    display_name="Echo Chain Demo",
    description="Demonstration of composite tool that chains multiple echo_tool calls",
    category="demo",
    version="1.0.0",
    tags=['composite', 'demo', 'echo'],
    enabled=True,
    requires_auth=True,
    required_permissions=[],
    requires_casefile=False,
    timeout_seconds=60,
    params_model=EchochaindemoParams,
    session_policies={'requires_active_session': True, 'allow_new_session': False, 'allow_session_resume': True, 'session_event_type': 'request', 'log_request_payload': True, 'log_full_response': True},
    casefile_policies={'requires_casefile': False, 'allowed_casefile_states': ['active'], 'enforce_access_control': False, 'create_if_missing': False, 'audit_casefile_changes': True},
    audit_config={'success_event': 'composite.echo_chain_demo.success', 'failure_event': 'composite.echo_chain_demo.failure', 'emit_casefile_event': True, 'log_response_fields': [], 'redact_fields': []},
)
async def echo_chain_demo(
    ctx: MDSContext,
    initial_message: str) -> Dict[str, Any]:
    """Demonstration of composite tool that chains multiple echo_tool calls
    
    Args:
        ctx: MDSContext with user_id, session_id, etc.
        initial_message: Initial message to start the chain
    
    Returns:
        Dict containing execution results
    """
    # Register event for audit trail
    event_id = ctx.register_event(
        "echo_chain_demo",
        {
            "initial_message": initial_message        }
    )
    
    # Composite tool implementation - execute chain of tools
    executor = ChainExecutor(ctx)
    
    # Prepare initial state from input parameters
    initial_state = {
        "initial_message": initial_message,
    }
    
    # Define chain steps
    steps = [{"inputs": {"message": "{{ state.initial_message }}", "session_id": "chain_session"}, "on_failure": {"action": "stop"}, "on_success": {"map_outputs": {"data": "step1_result"}}, "tool": "echo_tool"}, {"inputs": {"message": "Step 2: Processing result from step 1", "session_id": "chain_session"}, "on_failure": {"action": "continue", "next": "echo_tool"}, "on_success": {"map_outputs": {"data": "step2_result"}}, "tool": "echo_tool"}, {"inputs": {"message": "Step 3: Final step in chain", "session_id": "chain_session"}, "on_failure": {"action": "stop"}, "on_success": {"map_outputs": {"data": "final_result"}}, "tool": "echo_tool"}]
    
    # Execute chain
    chain_result = await executor.execute_chain(
        steps=steps,
        initial_state=initial_state,
        chain_name="echo_chain_demo"
    )
    
    # Format result
    result = {
        "tool": "echo_chain_demo",
        "status": "success" if chain_result.get("success") else "failure",
        "chain_id": chain_result.get("chain_id"),
        "steps_executed": chain_result.get("steps_executed"),
        "data": chain_result
    }
    
    
    # Update audit trail
    if ctx.tool_events:
        last_event = ctx.tool_events[-1]
        last_event.result_summary = {
            "status": "success",
            "result_preview": str(result)[:100]
        }
        last_event.status = "success"
    
    return result