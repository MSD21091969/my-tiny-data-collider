"""Auto-generated tool: multi_echo_pipeline

Generated from: config/tools/multi_echo_pipeline.yaml
DO NOT EDIT THIS FILE MANUALLY - Changes will be overwritten

This tool is part of the pydantic_ai_integration tool engineering foundation.
It was generated by the Tool Factory and automatically registered with MANAGED_TOOLS.
"""
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List
from ...tool_decorator import register_mds_tool
from ...dependencies import MDSContext
from ..chain_executor import ChainExecutor


class MultiechopipelineParams(BaseModel):
    """Parameters for multi_echo_pipeline.
    
    Chain multiple echo operations with state passing and conditional logic
    """
    initial_message: str = Field(
...,
min_length=1,        description="Initial message to echo through the pipeline"
    )
    repeat_count: Optional[int] = Field(
3,
ge=1,le=10,        description="Number of times to echo the message"
    )
    uppercase: Optional[bool] = Field(
False,
        description="Whether to convert message to uppercase in final step"
    )

    class Config:
        json_schema_extra = {
            "examples": [
                {
                    "initial_message": 'Hello World',                    "repeat_count": 3,                    "uppercase": False                }
            ]
        }


@register_mds_tool(
    name="multi_echo_pipeline",
    display_name="Multi-Step Echo Pipeline",
    description="Chain multiple echo operations with state passing and conditional logic",
    category="examples",
    version="1.0.0",
    tags=['composite', 'example', 'pipeline'],
    enabled=True,
    requires_auth=True,
    required_permissions=[],
    requires_casefile=False,
    timeout_seconds=60,
    params_model=MultiechopipelineParams,
    session_policies={'requires_active_session': True, 'allow_new_session': False, 'session_event_type': 'request', 'allow_session_resume': True, 'log_request_payload': True, 'log_full_response': True},
    casefile_policies={'requires_casefile': False, 'enforce_access_control': False, 'allowed_casefile_states': ['active'], 'create_if_missing': False, 'audit_casefile_changes': True},
    audit_config={'success_event': 'multi_echo_pipeline.success', 'failure_event': 'multi_echo_pipeline.failure', 'emit_casefile_event': False, 'log_response_fields': [], 'redact_fields': []},
)
async def multi_echo_pipeline(
    ctx: MDSContext,
    initial_message: str,    repeat_count: int = 3,    uppercase: bool = False) -> Dict[str, Any]:
    """Chain multiple echo operations with state passing and conditional logic
    
    Args:
        ctx: MDSContext with user_id, session_id, etc.
        initial_message: Initial message to echo through the pipeline
        repeat_count: Number of times to echo the message
        uppercase: Whether to convert message to uppercase in final step
    
    Returns:
        Dict containing execution results
    """
    # Register event for audit trail
    event_id = ctx.register_event(
        "multi_echo_pipeline",
        {
            "initial_message": initial_message,            "repeat_count": repeat_count,            "uppercase": uppercase        }
    )
    
    # Composite tool implementation - execute chain of tools
    executor = ChainExecutor(ctx)
    
    # Prepare initial state from input parameters
    initial_state = {
        "initial_message": initial_message,
        "repeat_count": repeat_count,
        "uppercase": uppercase,
    }
    
    # Define chain steps
    steps = [{"inputs": {"message": "{{ state.initial_message }}", "metadata": {"step": "step_1_initial", "timestamp": "{{ state.started_at }}"}}, "on_failure": {"action": "stop"}, "on_success": {"map_outputs": {"message": "step1_result"}, "next": "echo_tool"}, "tool": "echo_tool"}, {"inputs": {"message": "Step 2: {{ state.step1_result }}", "metadata": {"repeat_count": "{{ state.repeat_count }}", "step": "step_2_modified"}}, "on_failure": {"action": "retry", "max_retries": 2}, "on_success": {"map_outputs": {"message": "step2_result"}, "next": "echo_tool"}, "tool": "echo_tool"}, {"inputs": {"message": "Final: {{ state.step2_result }}", "metadata": {"step": "step_3_final", "uppercase": "{{ state.uppercase }}"}}, "on_failure": {"action": "continue"}, "on_success": {"map_outputs": {"message": "final_result"}}, "tool": "echo_tool"}]
    
    # Execute chain
    chain_result = await executor.execute_chain(
        steps=steps,
        initial_state=initial_state,
        chain_name="multi_echo_pipeline"
    )
    
    # Format result
    result = {
        "tool": "multi_echo_pipeline",
        "status": "success" if chain_result.get("success") else "failure",
        "chain_id": chain_result.get("chain_id"),
        "steps_executed": chain_result.get("steps_executed"),
        "data": chain_result
    }
    
    
    # Update audit trail
    if ctx.tool_events:
        last_event = ctx.tool_events[-1]
        last_event.result_summary = {
            "status": "success",
            "result_preview": str(result)[:100]
        }
        last_event.status = "success"
    
    return result