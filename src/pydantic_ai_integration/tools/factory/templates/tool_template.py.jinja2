"""Auto-generated tool: {{ tool.name }}

Generated from: config/tools/{{ tool.yaml_relative_path }}
DO NOT EDIT THIS FILE MANUALLY - Changes will be overwritten

TEMPLATE STATUS: âœ… UP TO DATE (Last sync: October 8, 2025 - Foundation Sync)

This tool is part of the pydantic_ai_integration tool engineering foundation.
It was generated by the Tool Factory and automatically registered with MANAGED_TOOLS.
"""
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List
from ....tool_decorator import register_mds_tool
from ....dependencies import MDSContext
{% if tool.implementation.type == 'composite' %}
from ....execution.chain_executor import ChainExecutor
{% endif %}


class {{ tool.name | capitalize | replace('_', '') }}Params(BaseModel):
    """Parameters for {{ tool.name }}.
    
    {{ tool.description }}
    """
    {% for param in tool.parameters %}
    {{ param.name }}: {% if not param.required %}Optional[{% endif %}{{ param.python_type }}{% if not param.required %}]{% endif %} = Field({% if param.required %}...{% else %}{{ param.default_value }}{% endif %}, description="{{ param.description }}"{% if param.get('min_value') is not none %}, ge={{ param.min_value }}{% endif %}{% if param.get('max_value') is not none %}, le={{ param.max_value }}{% endif %}{% if param.get('min_length') is not none %}, min_length={{ param.min_length }}{% endif %}{% if param.get('max_length') is not none %}, max_length={{ param.max_length }}{% endif %})
    {% endfor %}

    class Config:
        json_schema_extra = {
            "examples": [
                {
                    {% for param in tool.parameters %}
                    "{{ param.name }}": {{ param.example_value }}{% if not loop.last %},{% endif %}
                    {% endfor %}
                }
            ]
        }


@register_mds_tool(
    name="{{ tool.name }}",
    params_model={{ tool.name | capitalize | replace('_', '') }}Params,
    description="{{ tool.description }}",
    category="{{ tool.category }}",
    version="{{ tool.version }}",
    tags={{ tool.tags }},
    {% if tool.implementation.api_call and tool.implementation.api_call.method_name %}
    method_name="{{ tool.implementation.api_call.method_name }}",
    {% endif %}
)
async def {{ tool.name }}(
    ctx: MDSContext,
    {% for param in tool.parameters %}
    {{ param.name }}: {{ param.python_type }}{% if not param.required %} = {{ param.default_value }}{% endif %}{% if not loop.last %},{% endif %}
    {% endfor %}
) -> Dict[str, Any]:
    """{{ tool.description }}
    
    Args:
        ctx: MDSContext with user_id, session_id, etc.
        {% for param in tool.parameters %}
        {{ param.name }}: {{ param.description }}
        {% endfor %}
    
    Returns:
        Dict containing execution results
    """
    # Register event for audit trail
    event_id = ctx.register_event(
        "{{ tool.name }}",
        {
            {% for param in tool.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
    )
    
    {% if tool.implementation.type == 'simple' %}
    # Simple implementation
    {% if tool.implementation.simple and tool.implementation.simple.logic %}
    {{ tool.implementation.simple.logic | indent(4) }}
    {% else %}
    # Default simple result
    result = {
        "tool": "{{ tool.name }}",
        "status": "success",
        {% for param in tool.parameters %}
        "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
        {% endfor %}
    }
    {% endif %}
    
    {% elif tool.implementation.type == 'composite' %}
    # Composite tool implementation - execute chain of tools
    executor = ChainExecutor(ctx)
    
    # Prepare initial state from input parameters
    initial_state = {
        {% for param in tool.parameters %}
        "{{ param.name }}": {{ param.name }},
        {% endfor %}
    }
    
    # Define chain steps
    steps = {{ tool.implementation.composite.steps | tojson }}
    
    # Execute chain
    chain_result = await executor.execute_chain(
        steps=steps,
        initial_state=initial_state,
        chain_name="{{ tool.name }}"
    )
    
    # Format result
    result = {
        "tool": "{{ tool.name }}",
        "status": "success" if chain_result.get("success") else "failure",
        "chain_id": chain_result.get("chain_id"),
        "steps_executed": chain_result.get("steps_executed"),
        "data": chain_result
    }
    
    {% elif tool.implementation.type == 'api_call' and tool.implementation.api_call %}
    # API call implementation - inherit DTOs from method definition
    {% set api = tool.implementation.api_call %}
    {% set method_meta = api._method_metadata %}
    {% if method_meta %}
    # Import method's service class
    from {{ method_meta['module_path'] }} import {{ method_meta['implementation_class'] }}
    {% if method_meta['request_model'] and method_meta.get('models_module') %}
    from {{ method_meta['models_module'] }} import {{ method_meta['request_model'] }}
    {% endif %}
    {% if method_meta['response_model'] and method_meta.get('models_module') %}
    from {{ method_meta['models_module'] }} import {{ method_meta['response_model'] }}
    {% endif %}
    
    # Initialize service (dependency injection will provide actual instance)
    service = {{ method_meta['implementation_class'] }}()
    
    # Build request using method's DTO
    {% if method_meta['request_model'] %}
    request = {{ method_meta['request_model'] }}(
        user_id=ctx.user_id,
        session_id=ctx.session_id,
        context=ctx.model_dump(),
        payload={
            {% for param in tool.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
    )
    response = await service.{{ api.method_name or method_meta.method_name or tool.name }}(request=request)
    {% else %}
    # Direct method call without request envelope
    response = await service.{{ api.method_name or method_meta.method_name or tool.name }}(
        {% for param in tool.parameters %}
        {{ param.name }}={{ param.name }}{% if not loop.last %},{% endif %}
        {% endfor %}
    )
    {% endif %}
    
    #Extract result from response using method's DTO
    {% if method_meta.get('response_model') %}
    result = response.payload.model_dump() if hasattr(response.payload, 'model_dump') else response.payload
    {% else %}
    result = response.model_dump() if hasattr(response, 'model_dump') else response
    {% endif %}
    
    {% else %}
    # Fallback: manual API call implementation (for tools without method inheritance)
    {% set service_class = api.get('service_class') or api.get('client_class') or api.get('service') %}
    {% set module_path = api.get('module_path') or api.get('client_module') or 'coreservice.request_hub' %}
    {% set request_model = api.get('request_model') or api.get('request_type') %}
    {% if service_class and module_path %}
    from {{ module_path }} import {{ service_class }}
    {% if request_model %}
    {% set models_mod = api.get('models_module') or module_path.replace('.service', '.models') %}
    from {{ models_mod }} import {{ request_model }}
    {% endif %}
    
    # Initialize service/client (no parameters - services use dependency injection)
    service = {{ service_class }}()
    
    # Build request with BaseRequest envelope fields
    {% if request_model %}
    request = {{ request_model }}(
        user_id=ctx.user_id,
        session_id=ctx.session_id,
        context=ctx.model_dump(),
        payload={
            {% for param in tool.parameters %}
            "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
            {% endfor %}
        }
    )
    response = await service.{{ api.get('method_name', 'execute') }}(request=request)
    {% else %}
    # No request model - call method directly with parameters
    response = await service.{{ api.get('method_name', 'execute') }}(**{
        {% for param in tool.parameters %}
        "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
        {% endfor %}
    })
    {% endif %}
    
    # Extract result
    result = response.model_dump() if hasattr(response, 'model_dump') else response
    {% else %}
    # ERROR: Missing required service/module information in api_call
    raise ValueError("API call configuration missing service_class and module_path")
    {% endif %}
    {% endif %}
    
    {% else %}
    # Placeholder for {{ tool.implementation.type }} implementation
    result = {
        "tool": "{{ tool.name }}",
        "status": "success",
        "implementation_type": "{{ tool.implementation.type }}",
        {% for param in tool.parameters %}
        "{{ param.name }}": {{ param.name }}{% if not loop.last %},{% endif %}
        {% endfor %}
    }
    {% endif %}
    
    # Update audit trail
    if ctx.tool_events:
        last_event = ctx.tool_events[-1]
        last_event.result_summary = {
            "status": "success",
            "result_preview": str(result)[:100]
        }
        last_event.status = "success"
    
    return result
