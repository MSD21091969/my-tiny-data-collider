# Tool Engineering Architecture: Complete Classification

*Created: October 8, 2025*

## Architectural Foundation

### Complete Model Hierarchy

```
Layer 0: Base Infrastructure
    BaseModel (Pydantic)
        ↓
    BaseRequest[RequestPayloadT] (Generic)
    BaseResponse[ResponsePayloadT] (Generic)
        - request_id: UUID
        - session_id: Optional[str]
        - user_id: str
        - operation: str
        - payload: PayloadT
        - metadata: Dict[str, Any]

Layer 1: Payload Models (Business Data)
    {Action}Payload (BaseModel)
        Examples:
        - CreateCasefilePayload(title, description, tags)
        - ToolRequestPayload(tool_name, parameters, casefile_id)
        - ChatMessagePayload(message, model, temperature)

Layer 2: Request/Response DTOs (Method Contracts)
    {Action}Request(BaseRequest[{Action}Payload])
    {Action}Response(BaseResponse[{Action}ResponsePayload])
        Examples:
        - CreateCasefileRequest(BaseRequest[CreateCasefilePayload])
        - CreateCasefileResponse(BaseResponse[CasefilePayload])

Layer 3: Method Definitions (Registry Metadata)
    ManagedMethodDefinition
        - metadata: MethodMetadata (name, classification, docs)
        - business_rules: MethodBusinessRules (permissions, timeout)
        - parameters: List[MethodParameterDef] (from request payload)
        - models: MethodModels (request/response class references)
        - implementation: Service method reference

Layer 4: Tool Definitions (Registry Metadata)
    ManagedToolDefinition
        - metadata: ToolMetadata (name, description, category)
        - business_rules: ToolBusinessRules (enabled, permissions)
        - session_policies: ToolSessionPolicies
        - casefile_policies: ToolCasefilePolicies
        - parameters: List[ToolParameterDef] (inherited from method)
        - implementation: Tool function reference

Layer 5: Tool Execution Envelope (System Level)
    ToolRequest(BaseRequest[ToolRequestPayload])
        payload.parameters: Dict[str, Any] → Method Request Payload
    ToolResponse(BaseResponse[ToolResponsePayload])
        payload.result: Method Response Payload

Layer 6: YAML Configuration (Source of Truth)
    methods_inventory_v1.yaml → ManagedMethodDefinition → MANAGED_METHODS
    tool_xxx.yaml → ManagedToolDefinition → MANAGED_TOOLS
```

---

## Complete Relationship Map

### 1. YAML → Method Definition
```yaml
# methods_inventory_v1.yaml
method:
  name: create_casefile
  classification:
    domain: workspace
    subdomain: casefile
    capability: create
  models:
    request: CreateCasefileRequest
    response: CreateCasefileResponse
    module: src.pydantic_models.operations.casefile_ops
```
↓ **Loaded by method_registry.py**
```python
ManagedMethodDefinition(
    metadata=MethodMetadata(
        name="create_casefile",
        domain="workspace",
        subdomain="casefile",
        capability="create"
    ),
    models=MethodModels(
        request_model_class=CreateCasefileRequest,
        response_model_class=CreateCasefileResponse
    ),
    parameters=[
        MethodParameterDef(name="title", param_type="str", required=True),
        MethodParameterDef(name="description", param_type="Optional[str]")
    ]
)
```

### 2. Method Definition → DTO Models
```python
# src/pydantic_models/operations/casefile_ops.py

class CreateCasefilePayload(BaseModel):
    """Layer 1: Business data"""
    title: str
    description: Optional[str] = None
    tags: List[str] = []

class CreateCasefileRequest(BaseRequest[CreateCasefilePayload]):
    """Layer 2: Method contract"""
    operation: Literal["create_casefile"] = "create_casefile"
    # Inherits: request_id, session_id, user_id, payload, metadata

class CasefilePayload(BaseModel):
    """Layer 1: Response data"""
    casefile_id: str
    title: str
    created_at: str

class CreateCasefileResponse(BaseResponse[CasefilePayload]):
    """Layer 2: Method response"""
    # Inherits: request_id, status, payload, error, metadata
```

### 3. Tool YAML → Tool Definition
```yaml
# tool.yaml
name: create_casefile_tool
implementation:
  type: api_call
  method_name: workspace.casefile.create_casefile  # REFERENCE
# Classification INHERITED from method
# Parameters INHERITED from method
```
↓ **Generated by ToolFactory**
```python
ManagedToolDefinition(
    metadata=ToolMetadata(
        name="create_casefile_tool",
        description="Creates new casefile"  # From method
    ),
    parameters=[  # INHERITED from method
        ToolParameterDef(name="title", param_type="string", required=True)
    ],
    implementation=async_tool_function
)
```

### 4. Tool Execution → Method Invocation
```python
# Step 1: User makes tool request
tool_request = ToolRequest(
    user_id="user123",
    payload=ToolRequestPayload(
        tool_name="create_casefile_tool",
        parameters={"title": "X"}  # Dict[str, Any]
    )
)

# Step 2: Tool maps to method DTO
method = get_method("workspace.casefile.create_casefile")
method_request = CreateCasefileRequest(
    user_id=tool_request.user_id,
    operation="create_casefile",
    payload=CreateCasefilePayload(**tool_request.payload.parameters)
)

# Step 3: Method executes
method_response = await service.create_casefile(method_request)

# Step 4: Tool wraps response
tool_response = ToolResponse(
    request_id=tool_request.request_id,
    payload=ToolResponsePayload(
        result=method_response.payload.dict()  # Typed → Dict
    )
)
```

---

## Classification Taxonomy

**Shared by Methods and Tools** (inherited from methods):

```yaml
classification:
  domain: workspace|communication|automation
    workspace: Files, documents, casefiles, storage
    communication: Email, chat, messaging, notifications
    automation: Workflows, pipelines, orchestration
  
  subdomain: Specific area
    workspace: casefile, google_drive, google_sheets
    communication: gmail, chat_session, notifications
    automation: tool_session, tool_execution, pipelines
  
  capability: Operation type
    create: Creates new resources
    read: Retrieves/queries data
    update: Modifies existing resources
    delete: Removes resources
    process: Transforms/analyzes data
    search: Filters/searches data
  
  complexity: Composition level
    atomic: Single operation, no dependencies
    composite: Multiple operations combined
    pipeline: Multi-step workflow with orchestration
  
  maturity: Development stage
    stable: Production ready
    beta: Feature complete, testing
    alpha: Early development
  
  integration_tier: External dependencies
    internal: Only internal services
    external: Requires external APIs
    hybrid: Internal + external
```

---

## Model Naming Conventions

### Payload Models (Layer 1)
```python
{Action}Payload          # Request business data
{Entity}Payload          # Response business data

Examples:
CreateCasefilePayload    # Request: title, description, tags
CasefilePayload          # Response: casefile_id, title, created_at
ToolRequestPayload       # Request: tool_name, parameters
ToolResponsePayload      # Response: result, events
```

### Request/Response Models (Layer 2)
```python
{Action}Request(BaseRequest[{Action}Payload])
{Action}Response(BaseResponse[{Result}Payload])

Examples:
CreateCasefileRequest(BaseRequest[CreateCasefilePayload])
CreateCasefileResponse(BaseResponse[CasefilePayload])
ToolRequest(BaseRequest[ToolRequestPayload])
ToolResponse(BaseResponse[ToolResponsePayload])
```

### Definition Models (Layer 3-4)
```python
ManagedMethodDefinition  # Method registry entry
ManagedToolDefinition    # Tool registry entry
MethodParameterDef       # Method parameter metadata
ToolParameterDef         # Tool parameter metadata
```

---

## Critical Architectural Rules

### 1. Single Source of Truth
```
methods_inventory_v1.yaml (YAML)
    ↓ defines
ManagedMethodDefinition (Registry)
    ↓ references
{Action}Request/Response (DTOs)
    ↓ contains
{Action}Payload (Business Data)
```

**Rule**: Methods define contracts, tools inherit them.

### 2. Type Safety Chain
```
Dict[str, Any] (Tool parameters)
    ↓ validated by
ToolParameterDef (Tool definition)
    ↓ maps to
{Action}Payload (Typed model)
    ↓ wrapped in
{Action}Request (Method DTO)
```

**Rule**: Type safety at boundaries, generic at transport.

### 3. Layer Separation
```
ToolRequest (System envelope)
    ≠ (different concern)
CreateCasefileRequest (Method DTO)
```

**Rule**: Tool layer handles system concerns (audit, session), method layer handles business logic.

### 4. Classification Inheritance
```
Method classification (in methods_inventory_v1.yaml)
    ↓ inherited by
Tool classification (in tool YAML)
```

**Rule**: Tools don't define their own classification, they inherit from referenced method.

### 5. R-A-R Pattern
```
{Action}Request(BaseRequest[{Action}Payload])
    operation="action_name"
    payload={Action}Payload(business_data)
```

**Rule**: All method DTOs follow Request-Action-Response pattern.

---

## Current State Analysis

### ✅ Correct Implementations
1. **Casefile Operations**: Full R-A-R pattern, proper inheritance
2. **Tool Session Operations**: Consistent payload models
3. **Base Infrastructure**: Generic BaseRequest/BaseResponse

### ❌ Inconsistencies Found

#### 1. Google Workspace Models
**Problem**: Don't use BaseRequest/BaseResponse
```python
# Current (plain Pydantic)
class GmailListMessagesRequest(BaseModel):
    user_id: str
    query: str
```

**Should be** (external API data, keep as plain):
```python
# Keep as plain Pydantic (external API data)
class GmailListMessagesRequest(BaseModel):
    query: str
```

**Fix**: Update methods_inventory_v1.yaml to reflect actual models.

#### 2. ChatRequest R-A-R Violation
**Problem**: Uses `ChatMessagePayload` instead of `ChatRequestPayload`
```python
# Current (inconsistent)
class ChatRequest(BaseRequest[ChatMessagePayload]):
    pass
```

**Should be**:
```python
class ChatRequestPayload(BaseModel):
    message: str
    model: str
    temperature: float

class ChatRequest(BaseRequest[ChatRequestPayload]):
    operation: Literal["chat"] = "chat"
```

#### 3. Tool YAML Parameter Duplication
**Problem**: Tool YAMLs define parameters instead of inheriting
```yaml
# Current (redundant)
parameters:
  - name: title
    type: string
    required: true
```

**Should be**:
```yaml
# Inheritance (no duplication)
implementation:
  type: api_call
  method_name: workspace.casefile.create_casefile
# Parameters inherited automatically
```

#### 4. ManagedToolDefinition Structure Mismatch
**Problem**: Code structure ≠ tool_schema_v2.yaml structure

**Fix**: Align tool_definition.py with YAML schema.

---

## Implementation Priorities

### Priority 1: DTO Inheritance
1. Update ToolFactory to resolve methods from MANAGED_METHODS
2. Extract parameters from method DTOs automatically
3. Remove parameter duplication from tool YAMLs
4. Generate tools with inherited classification

### Priority 2: R-A-R Alignment
1. Fix ChatRequest to use ChatRequestPayload
2. Audit all DTOs for R-A-R compliance
3. Ensure consistent naming: {Action}Request(BaseRequest[{Action}Payload])
4. Update methods_inventory_v1.yaml with correct models

### Priority 3: Classification Validation
1. Validate tool classification matches referenced method
2. Add drift detection in ToolFactory
3. Ensure methods_inventory_v1.yaml references actual DTO classes
4. Document classification inheritance rules

---

## Foundation Validation Checklist

- [ ] All methods have valid DTO references in methods_inventory_v1.yaml
- [ ] All DTOs follow R-A-R pattern: {Action}Request(BaseRequest[{Action}Payload])
- [ ] Tool YAMLs reference methods, don't duplicate parameters
- [ ] Google Workspace models correctly classified (external API data)
- [ ] ManagedToolDefinition structure matches tool_schema_v2.yaml
- [ ] ToolRequest.payload.parameters maps to Method DTO payload
- [ ] Tool classification inherited from referenced method
- [ ] No drift between YAML, registry, and DTO definitions

---

*This document defines the complete architectural foundation for tool engineering.*
