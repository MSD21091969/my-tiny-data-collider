# YAML-Driven Payload Models

**Date:** October 2, 2025  
**Status:** ðŸ“ Technical Reference  
**Purpose:** Explain how tool payload models (parameters and returns) are fully designed in YAML

---

## ðŸŽ¯ Yes! Payload Models are 100% YAML-Driven

The **Tool Factory** generates complete Pydantic models for:
1. **Input Parameters** (`parameters` section in YAML)
2. **Return Types** (`returns` section in YAML)
3. **Validation Constraints** (min/max, required, defaults)

**No manual model coding required!**

---

## ðŸ“Š YAML â†’ Pydantic Model Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  YAML Definition                                            â”‚
â”‚  config/tools/echo_tool.yaml                                â”‚
â”‚                                                             â”‚
â”‚  parameters:                                                â”‚
â”‚    - name: message                                          â”‚
â”‚      type: string                                           â”‚
â”‚      required: true                                         â”‚
â”‚      min_length: 1                                          â”‚
â”‚      max_length: 500                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                    Tool Factory Parses
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Generated Pydantic Model                                   â”‚
â”‚  src/pydantic_ai_integration/tools/generated/echo_tool.py   â”‚
â”‚                                                             â”‚
â”‚  class EchotoolParams(BaseModel):                          â”‚
â”‚      message: str = Field(                                  â”‚
â”‚          ...,                    # required                 â”‚
â”‚          min_length=1,                                      â”‚
â”‚          max_length=500,                                    â”‚
â”‚          description="Message to echo back"                 â”‚
â”‚      )                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                    Used at Runtime
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Automatic Validation                                       â”‚
â”‚  Pydantic validates all inputs before tool execution        â”‚
â”‚                                                             â”‚
â”‚  EchotoolParams(message="")  # ValidationError: too short   â”‚
â”‚  EchotoolParams(message="x"*1000)  # ValidationError: too longâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“ Complete Example: Input Parameters

### **YAML Definition**

```yaml
# config/tools/echo_tool.yaml
parameters:
  - name: message
    type: string                # â†’ str
    required: true              # â†’ Field(...)
    min_length: 1               # â†’ min_length=1
    max_length: 500             # â†’ max_length=500
    description: "Message to echo back"
    
  - name: repeat_count
    type: integer               # â†’ int
    required: false             # â†’ Optional[int]
    default: 1                  # â†’ Field(default=1)
    min_value: 1                # â†’ ge=1
    max_value: 10               # â†’ le=10
    description: "Number of times to repeat"
```

### **Generated Pydantic Model**

```python
# Generated by Tool Factory
class EchotoolParams(BaseModel):
    """Parameters for echo_tool."""
    
    message: str = Field(
        ...,                    # Required (from required: true)
        min_length=1,           # From min_length: 1
        max_length=500,         # From max_length: 500
        description="Message to echo back"
    )
    
    repeat_count: Optional[int] = Field(
        1,                      # Default (from default: 1)
        ge=1,                   # Greater or equal (from min_value: 1)
        le=10,                  # Less or equal (from max_value: 10)
        description="Number of times to repeat"
    )
```

### **How It's Used**

```python
# Automatic validation at runtime
try:
    params = EchotoolParams(
        message="",         # Too short!
        repeat_count=1
    )
except ValidationError as e:
    print(e.errors())
    # [{'type': 'string_too_short', 'loc': ('message',), ...}]
```

---

## ðŸ”„ Supported Parameter Types

### **Basic Types**

| YAML Type | Python Type | Pydantic Field | Example |
|-----------|-------------|----------------|---------|
| `string` | `str` | `str` | `"hello"` |
| `integer` | `int` | `int` | `42` |
| `number` | `float` | `float` | `3.14` |
| `boolean` | `bool` | `bool` | `true` |
| `array` | `List[...]` | `List[...]` | `["a", "b"]` |
| `object` | `Dict[str, Any]` | `Dict[str, Any]` | `{"key": "val"}` |

### **Validation Constraints**

| Constraint | YAML Key | Pydantic Field | Example |
|------------|----------|----------------|---------|
| **Required** | `required: true` | `Field(...)` | Must be provided |
| **Optional** | `required: false` | `Optional[...]` | Can be None |
| **Default** | `default: value` | `Field(default=...)` | Used if not provided |
| **Min Length** | `min_length: 1` | `min_length=1` | String min chars |
| **Max Length** | `max_length: 500` | `max_length=500` | String max chars |
| **Min Value** | `min_value: 1` | `ge=1` | Number >= 1 |
| **Max Value** | `max_value: 10` | `le=10` | Number <= 10 |
| **Pattern** | `pattern: "^[a-z]+$"` | `pattern="^[a-z]+$"` | Regex validation |

### **Complex Types**

#### **Array with Item Type**
```yaml
parameters:
  - name: tags
    type: array
    items:
      type: string
    min_items: 1
    max_items: 10
```

**Generated:**
```python
tags: List[str] = Field(
    ...,
    min_length=1,
    max_length=10
)
```

#### **Object with Properties**
```yaml
parameters:
  - name: config
    type: object
    properties:
      mode:
        type: string
      timeout:
        type: integer
```

**Generated:**
```python
config: Dict[str, Any] = Field(...)
# Or with nested model:
class ConfigModel(BaseModel):
    mode: str
    timeout: int
```

---

## ðŸ“¤ Return Type Specification

### **YAML Definition**

```yaml
# config/tools/echo_tool.yaml
returns:
  type: object
  description: "Echo results with metadata"
  required:
    - original_message
    - repeat_count
    - echoed_messages
    - total_length
  properties:
    original_message:
      type: string
      description: "The input message"
    repeat_count:
      type: integer
      description: "Number of repetitions"
    echoed_messages:
      type: array
      description: "List of echoed messages"
      items:
        type: string
    total_length:
      type: integer
      description: "Total character count"
```

### **Generated Function Signature**

```python
async def echo_tool(
    ctx: MDSContext,
    message: str,
    repeat_count: int = 1
) -> Dict[str, Any]:          # â† Return type from YAML
    """Echoes input message back with metadata
    
    Returns:
        Dict containing:
        - original_message: str
        - repeat_count: int
        - echoed_messages: List[str]
        - total_length: int
    """
    return {
        "original_message": message,
        "repeat_count": repeat_count,
        "echoed_messages": [...],
        "total_length": ...
    }
```

### **Return Type Validation** (Optional)

While the tool returns `Dict[str, Any]`, you can optionally define a return model:

```yaml
returns:
  type: object
  model_name: EchoToolResponse  # Optional: generate return model
  properties:
    original_message:
      type: string
    # ...
```

**Would Generate:**
```python
class EchoToolResponse(BaseModel):
    original_message: str
    repeat_count: int
    echoed_messages: List[str]
    total_length: int

async def echo_tool(...) -> EchoToolResponse:
    # Return validated model
    return EchoToolResponse(
        original_message=message,
        repeat_count=repeat_count,
        echoed_messages=echoed_messages,
        total_length=total_length
    )
```

---

## ðŸŽ¨ Advanced Parameter Examples

### **Example 1: Gmail List Messages**

```yaml
name: gmail_list_messages
parameters:
  - name: max_results
    type: integer
    required: false
    default: 10
    min_value: 1
    max_value: 500
    description: "Maximum messages to retrieve"
    
  - name: query
    type: string
    required: false
    default: ""
    max_length: 500
    description: "Gmail search query"
    
  - name: label_ids
    type: array
    required: false
    items:
      type: string
    max_items: 10
    description: "Filter by label IDs"
```

**Generates:**
```python
class GmailListMessagesParams(BaseModel):
    max_results: int = Field(
        default=10,
        ge=1,
        le=500,
        description="Maximum messages to retrieve"
    )
    query: str = Field(
        default="",
        max_length=500,
        description="Gmail search query"
    )
    label_ids: Optional[List[str]] = Field(
        default=None,
        max_length=10,
        description="Filter by label IDs"
    )
```

---

### **Example 2: Drive Upload File**

```yaml
name: drive_upload_file
parameters:
  - name: filename
    type: string
    required: true
    min_length: 1
    max_length: 255
    pattern: "^[^/\\\\:*?\"<>|]+$"  # No invalid chars
    description: "File name"
    
  - name: content
    type: string
    required: true
    description: "File content (base64 or text)"
    
  - name: parent_folder_id
    type: string
    required: false
    pattern: "^[a-zA-Z0-9_-]+$"
    description: "Parent folder ID"
    
  - name: mime_type
    type: string
    required: false
    default: "text/plain"
    description: "MIME type"
```

**Generates:**
```python
class DriveUploadFileParams(BaseModel):
    filename: str = Field(
        ...,
        min_length=1,
        max_length=255,
        pattern=r"^[^/\\:*?\"<>|]+$",
        description="File name"
    )
    content: str = Field(
        ...,
        description="File content (base64 or text)"
    )
    parent_folder_id: Optional[str] = Field(
        default=None,
        pattern=r"^[a-zA-Z0-9_-]+$",
        description="Parent folder ID"
    )
    mime_type: str = Field(
        default="text/plain",
        description="MIME type"
    )
```

---

### **Example 3: Sheets Batch Update**

```yaml
name: sheets_batch_update
parameters:
  - name: spreadsheet_id
    type: string
    required: true
    pattern: "^[a-zA-Z0-9_-]+$"
    description: "Spreadsheet ID"
    
  - name: updates
    type: array
    required: true
    min_items: 1
    max_items: 100
    items:
      type: object
      properties:
        range:
          type: string
        values:
          type: array
    description: "List of cell updates"
```

**Generates:**
```python
class UpdateEntry(BaseModel):
    range: str
    values: List[Any]

class SheetsBatchUpdateParams(BaseModel):
    spreadsheet_id: str = Field(
        ...,
        pattern=r"^[a-zA-Z0-9_-]+$",
        description="Spreadsheet ID"
    )
    updates: List[UpdateEntry] = Field(
        ...,
        min_length=1,
        max_length=100,
        description="List of cell updates"
    )
```

---

## ðŸ” How Tool Factory Generates Models

### **Step 1: Parse YAML**

```python
# src/pydantic_ai_integration/tools/factory/__init__.py
def _parse_parameters(self, params_list: List[Dict]) -> List[Dict]:
    """Parse YAML parameters into parameter specs."""
    parsed = []
    for param in params_list:
        parsed.append({
            'name': param['name'],
            'type': param['type'],
            'required': param.get('required', False),
            'default': param.get('default'),
            'min_length': param.get('min_length'),
            'max_length': param.get('max_length'),
            'min_value': param.get('min_value'),
            'max_value': param.get('max_value'),
            'pattern': param.get('pattern'),
            'description': param.get('description', ''),
        })
    return parsed
```

### **Step 2: Generate Pydantic Fields**

```python
# In Jinja2 template: templates/tool_template.py.jinja2
class {{ params_class_name }}(BaseModel):
    """Parameters for {{ tool_name }}."""
    {% for param in parameters %}
    {{ param.name }}: {{ param.python_type }} = Field(
        {% if param.required %}...{% else %}{{ param.default }}{% endif %},
        {% if param.min_length %}min_length={{ param.min_length }},{% endif %}
        {% if param.max_length %}max_length={{ param.max_length }},{% endif %}
        {% if param.min_value %}ge={{ param.min_value }},{% endif %}
        {% if param.max_value %}le={{ param.max_value }},{% endif %}
        {% if param.pattern %}pattern=r"{{ param.pattern }}",{% endif %}
        description="{{ param.description }}"
    )
    {% endfor %}
```

### **Step 3: Type Mapping**

```python
TYPE_MAPPING = {
    'string': 'str',
    'integer': 'int',
    'number': 'float',
    'boolean': 'bool',
    'array': 'List[Any]',
    'object': 'Dict[str, Any]',
}

def get_python_type(yaml_type: str, required: bool) -> str:
    """Convert YAML type to Python type hint."""
    base_type = TYPE_MAPPING.get(yaml_type, 'Any')
    if not required:
        return f"Optional[{base_type}]"
    return base_type
```

---

## ðŸ“‹ Complete Parameter Reference

### **All Supported YAML Keys**

```yaml
parameters:
  - name: param_name              # Required: parameter name
    type: string                  # Required: data type
    required: true|false          # Optional: default false
    default: value                # Optional: default value
    description: "..."            # Optional: parameter description
    
    # String constraints
    min_length: 1                 # Minimum string length
    max_length: 500               # Maximum string length
    pattern: "^[a-z]+$"           # Regex pattern
    
    # Number constraints
    min_value: 1                  # Minimum value (>=)
    max_value: 100                # Maximum value (<=)
    
    # Array constraints
    items:                        # Array item type
      type: string
    min_items: 1                  # Minimum array length
    max_items: 10                 # Maximum array length
    
    # Object constraints
    properties:                   # Object structure
      key1:
        type: string
      key2:
        type: integer
```

---

## ðŸŽ¯ Benefits of YAML-Driven Models

### **1. No Boilerplate Code**
```yaml
# Just write this in YAML
parameters:
  - name: email
    type: string
    pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
```

Instead of:
```python
# Manually writing this
class MyToolParams(BaseModel):
    email: str = Field(
        ...,
        pattern=r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
        description="Email address"
    )
```

### **2. Consistency Across Tools**
All tools follow the same pattern, generated from templates.

### **3. Validation Rules in Config**
Change validation rules without touching code:
```yaml
# Week 1: max 100 messages
max_value: 100

# Week 2: increase to 500
max_value: 500
```
Regenerate â†’ new validation automatically applied.

### **4. Documentation from Schema**
YAML serves as both config and documentation:
```yaml
parameters:
  - name: timeout_seconds
    type: integer
    default: 30
    min_value: 1
    max_value: 300
    description: "Request timeout in seconds"
```

### **5. Test Generation**
Examples in YAML become tests automatically:
```yaml
examples:
  - description: "Valid email"
    input:
      email: "user@example.com"
    expected_output:
      status: "sent"
```

---

## ðŸ”„ Workflow: Adding a New Tool with Custom Models

### **Step 1: Define in YAML**

```yaml
# config/tools/send_email.yaml
name: send_email
parameters:
  - name: to_address
    type: string
    required: true
    pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    description: "Recipient email"
    
  - name: subject
    type: string
    required: true
    min_length: 1
    max_length: 200
    description: "Email subject"
    
  - name: body
    type: string
    required: true
    min_length: 1
    description: "Email body"
    
  - name: attachments
    type: array
    required: false
    items:
      type: string
    max_items: 5
    description: "Attachment file paths"
```

### **Step 2: Generate**

```bash
python -m scripts.main config/tools/send_email.yaml
```

### **Step 3: Generated Model**

```python
# Automatically created
class SendEmailParams(BaseModel):
    to_address: str = Field(
        ...,
        pattern=r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
        description="Recipient email"
    )
    subject: str = Field(
        ...,
        min_length=1,
        max_length=200,
        description="Email subject"
    )
    body: str = Field(
        ...,
        min_length=1,
        description="Email body"
    )
    attachments: Optional[List[str]] = Field(
        default=None,
        max_length=5,
        description="Attachment file paths"
    )
```

### **Step 4: Use**

```python
# Validation happens automatically
result = await send_email(
    ctx,
    to_address="user@example.com",
    subject="Hello",
    body="Test message",
    attachments=["file1.pdf", "file2.txt"]
)
```

---

## ðŸ“Š Summary

| Aspect | YAML-Driven? | How? |
|--------|-------------|------|
| **Parameter Names** | âœ… Yes | `parameters[].name` |
| **Parameter Types** | âœ… Yes | `parameters[].type` |
| **Required/Optional** | âœ… Yes | `parameters[].required` |
| **Default Values** | âœ… Yes | `parameters[].default` |
| **Validation Rules** | âœ… Yes | `min_length`, `max_value`, `pattern`, etc. |
| **Return Type** | âœ… Yes | `returns.type` and `returns.properties` |
| **Descriptions** | âœ… Yes | `parameters[].description` |
| **Test Examples** | âœ… Yes | `examples[].input` â†’ generated tests |

**Result**: **100% of payload model structure is YAML-driven!**

---

## ðŸŽ“ Next Steps

### **For Simple Tools**
Just define parameters in YAML, Tool Factory handles the rest.

### **For Complex Nested Models**
Consider creating shared models in `src/pydantic_models/` and referencing them:

```yaml
parameters:
  - name: config
    type: custom_model
    model_path: "src.pydantic_models.shared.EmailConfig"
```

### **For API Integration**
Use `implementation.type: api_call` with request/response mappings:

```yaml
implementation:
  type: api_call
  api_call:
    endpoint: "https://api.gmail.com/v1/messages/send"
    method: POST
    request_mapping:
      to: "{{to_address}}"
      subject: "{{subject}}"
      body: "{{body}}"
```

---

**Key Takeaway**: The Tool Factory is a **complete model generator** - you define the data shape in YAML, and it creates type-safe Pydantic models with full validation!

**Last Updated**: October 2, 2025
